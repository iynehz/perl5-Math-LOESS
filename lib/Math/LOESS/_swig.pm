# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Math::LOESS::_swig;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::LOESS::_swigc;
bootstrap Math::LOESS::_swig;
package Math::LOESS::_swig;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::LOESS::_swig;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::LOESS::_swig;

*loess_model_setup = *Math::LOESS::_swigc::loess_model_setup;
*loess_inputs_setup = *Math::LOESS::_swigc::loess_inputs_setup;
*loess_outputs_setup = *Math::LOESS::_swigc::loess_outputs_setup;
*loess_control_setup = *Math::LOESS::_swigc::loess_control_setup;
*loess_kd_tree_setup = *Math::LOESS::_swigc::loess_kd_tree_setup;
*loess_setup = *Math::LOESS::_swigc::loess_setup;
*loess_fit = *Math::LOESS::_swigc::loess_fit;
*loess_inputs_free = *Math::LOESS::_swigc::loess_inputs_free;
*loess_outputs_free = *Math::LOESS::_swigc::loess_outputs_free;
*loess_kd_tree_free = *Math::LOESS::_swigc::loess_kd_tree_free;
*loess_free_mem = *Math::LOESS::_swigc::loess_free_mem;
*loess_summary = *Math::LOESS::_swigc::loess_summary;
*loess_raw = *Math::LOESS::_swigc::loess_raw;
*loess_ise = *Math::LOESS::_swigc::loess_ise;
*loess_ifit = *Math::LOESS::_swigc::loess_ifit;
*loess_dfitse = *Math::LOESS::_swigc::loess_dfitse;
*loess_dfit = *Math::LOESS::_swigc::loess_dfit;
*safe_malloc = *Math::LOESS::_swigc::safe_malloc;
*pointwise = *Math::LOESS::_swigc::pointwise;
*pw_free_mem = *Math::LOESS::_swigc::pw_free_mem;
*pf = *Math::LOESS::_swigc::pf;
*ibeta = *Math::LOESS::_swigc::ibeta;
*predict = *Math::LOESS::_swigc::predict;
*pred_free_mem = *Math::LOESS::_swigc::pred_free_mem;
*new_doubleArray = *Math::LOESS::_swigc::new_doubleArray;
*delete_doubleArray = *Math::LOESS::_swigc::delete_doubleArray;
*doubleArray_getitem = *Math::LOESS::_swigc::doubleArray_getitem;
*doubleArray_setitem = *Math::LOESS::_swigc::doubleArray_setitem;

############# Class : Math::LOESS::_swig::loess_errstatus ##############

package Math::LOESS::_swig::loess_errstatus;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_err_status_get = *Math::LOESS::_swigc::loess_errstatus_err_status_get;
*swig_err_status_set = *Math::LOESS::_swigc::loess_errstatus_err_status_set;
*swig_err_msg_get = *Math::LOESS::_swigc::loess_errstatus_err_msg_get;
*swig_err_msg_set = *Math::LOESS::_swigc::loess_errstatus_err_msg_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess_errstatus(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess_errstatus($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::loess_inputs ##############

package Math::LOESS::_swig::loess_inputs;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_n_get = *Math::LOESS::_swigc::loess_inputs_n_get;
*swig_n_set = *Math::LOESS::_swigc::loess_inputs_n_set;
*swig_p_get = *Math::LOESS::_swigc::loess_inputs_p_get;
*swig_p_set = *Math::LOESS::_swigc::loess_inputs_p_set;
*swig_y_get = *Math::LOESS::_swigc::loess_inputs_y_get;
*swig_y_set = *Math::LOESS::_swigc::loess_inputs_y_set;
*swig_x_get = *Math::LOESS::_swigc::loess_inputs_x_get;
*swig_x_set = *Math::LOESS::_swigc::loess_inputs_x_set;
*swig_weights_get = *Math::LOESS::_swigc::loess_inputs_weights_get;
*swig_weights_set = *Math::LOESS::_swigc::loess_inputs_weights_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess_inputs(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess_inputs($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::loess_model ##############

package Math::LOESS::_swig::loess_model;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_span_get = *Math::LOESS::_swigc::loess_model_span_get;
*swig_span_set = *Math::LOESS::_swigc::loess_model_span_set;
*swig_degree_get = *Math::LOESS::_swigc::loess_model_degree_get;
*swig_degree_set = *Math::LOESS::_swigc::loess_model_degree_set;
*swig_normalize_get = *Math::LOESS::_swigc::loess_model_normalize_get;
*swig_normalize_set = *Math::LOESS::_swigc::loess_model_normalize_set;
*swig_parametric_get = *Math::LOESS::_swigc::loess_model_parametric_get;
*swig_parametric_set = *Math::LOESS::_swigc::loess_model_parametric_set;
*swig_drop_square_get = *Math::LOESS::_swigc::loess_model_drop_square_get;
*swig_drop_square_set = *Math::LOESS::_swigc::loess_model_drop_square_set;
*swig_family_get = *Math::LOESS::_swigc::loess_model_family_get;
*swig_family_set = *Math::LOESS::_swigc::loess_model_family_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess_model(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess_model($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::loess_control ##############

package Math::LOESS::_swig::loess_control;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_surface_get = *Math::LOESS::_swigc::loess_control_surface_get;
*swig_surface_set = *Math::LOESS::_swigc::loess_control_surface_set;
*swig_statistics_get = *Math::LOESS::_swigc::loess_control_statistics_get;
*swig_statistics_set = *Math::LOESS::_swigc::loess_control_statistics_set;
*swig_cell_get = *Math::LOESS::_swigc::loess_control_cell_get;
*swig_cell_set = *Math::LOESS::_swigc::loess_control_cell_set;
*swig_trace_hat_get = *Math::LOESS::_swigc::loess_control_trace_hat_get;
*swig_trace_hat_set = *Math::LOESS::_swigc::loess_control_trace_hat_set;
*swig_iterations_get = *Math::LOESS::_swigc::loess_control_iterations_get;
*swig_iterations_set = *Math::LOESS::_swigc::loess_control_iterations_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess_control(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess_control($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::loess_kd_tree ##############

package Math::LOESS::_swig::loess_kd_tree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_parameter_get = *Math::LOESS::_swigc::loess_kd_tree_parameter_get;
*swig_parameter_set = *Math::LOESS::_swigc::loess_kd_tree_parameter_set;
*swig_a_get = *Math::LOESS::_swigc::loess_kd_tree_a_get;
*swig_a_set = *Math::LOESS::_swigc::loess_kd_tree_a_set;
*swig_xi_get = *Math::LOESS::_swigc::loess_kd_tree_xi_get;
*swig_xi_set = *Math::LOESS::_swigc::loess_kd_tree_xi_set;
*swig_vert_get = *Math::LOESS::_swigc::loess_kd_tree_vert_get;
*swig_vert_set = *Math::LOESS::_swigc::loess_kd_tree_vert_set;
*swig_vval_get = *Math::LOESS::_swigc::loess_kd_tree_vval_get;
*swig_vval_set = *Math::LOESS::_swigc::loess_kd_tree_vval_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess_kd_tree(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess_kd_tree($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::loess_outputs ##############

package Math::LOESS::_swig::loess_outputs;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_fitted_values_get = *Math::LOESS::_swigc::loess_outputs_fitted_values_get;
*swig_fitted_values_set = *Math::LOESS::_swigc::loess_outputs_fitted_values_set;
*swig_fitted_residuals_get = *Math::LOESS::_swigc::loess_outputs_fitted_residuals_get;
*swig_fitted_residuals_set = *Math::LOESS::_swigc::loess_outputs_fitted_residuals_set;
*swig_enp_get = *Math::LOESS::_swigc::loess_outputs_enp_get;
*swig_enp_set = *Math::LOESS::_swigc::loess_outputs_enp_set;
*swig_residual_scale_get = *Math::LOESS::_swigc::loess_outputs_residual_scale_get;
*swig_residual_scale_set = *Math::LOESS::_swigc::loess_outputs_residual_scale_set;
*swig_one_delta_get = *Math::LOESS::_swigc::loess_outputs_one_delta_get;
*swig_one_delta_set = *Math::LOESS::_swigc::loess_outputs_one_delta_set;
*swig_two_delta_get = *Math::LOESS::_swigc::loess_outputs_two_delta_get;
*swig_two_delta_set = *Math::LOESS::_swigc::loess_outputs_two_delta_set;
*swig_pseudovalues_get = *Math::LOESS::_swigc::loess_outputs_pseudovalues_get;
*swig_pseudovalues_set = *Math::LOESS::_swigc::loess_outputs_pseudovalues_set;
*swig_trace_hat_get = *Math::LOESS::_swigc::loess_outputs_trace_hat_get;
*swig_trace_hat_set = *Math::LOESS::_swigc::loess_outputs_trace_hat_set;
*swig_diagonal_get = *Math::LOESS::_swigc::loess_outputs_diagonal_get;
*swig_diagonal_set = *Math::LOESS::_swigc::loess_outputs_diagonal_set;
*swig_robust_get = *Math::LOESS::_swigc::loess_outputs_robust_get;
*swig_robust_set = *Math::LOESS::_swigc::loess_outputs_robust_set;
*swig_divisor_get = *Math::LOESS::_swigc::loess_outputs_divisor_get;
*swig_divisor_set = *Math::LOESS::_swigc::loess_outputs_divisor_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess_outputs(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess_outputs($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::loess ##############

package Math::LOESS::_swig::loess;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_inputs_get = *Math::LOESS::_swigc::loess_inputs_get;
*swig_inputs_set = *Math::LOESS::_swigc::loess_inputs_set;
*swig_model_get = *Math::LOESS::_swigc::loess_model_get;
*swig_model_set = *Math::LOESS::_swigc::loess_model_set;
*swig_control_get = *Math::LOESS::_swigc::loess_control_get;
*swig_control_set = *Math::LOESS::_swigc::loess_control_set;
*swig_kd_tree_get = *Math::LOESS::_swigc::loess_kd_tree_get;
*swig_kd_tree_set = *Math::LOESS::_swigc::loess_kd_tree_set;
*swig_outputs_get = *Math::LOESS::_swigc::loess_outputs_get;
*swig_outputs_set = *Math::LOESS::_swigc::loess_outputs_set;
*swig_status_get = *Math::LOESS::_swigc::loess_status_get;
*swig_status_set = *Math::LOESS::_swigc::loess_status_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_loess(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_loess($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::prediction ##############

package Math::LOESS::_swig::prediction;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_fit_get = *Math::LOESS::_swigc::prediction_fit_get;
*swig_fit_set = *Math::LOESS::_swigc::prediction_fit_set;
*swig_se_fit_get = *Math::LOESS::_swigc::prediction_se_fit_get;
*swig_se_fit_set = *Math::LOESS::_swigc::prediction_se_fit_set;
*swig_se_get = *Math::LOESS::_swigc::prediction_se_get;
*swig_se_set = *Math::LOESS::_swigc::prediction_se_set;
*swig_m_get = *Math::LOESS::_swigc::prediction_m_get;
*swig_m_set = *Math::LOESS::_swigc::prediction_m_set;
*swig_residual_scale_get = *Math::LOESS::_swigc::prediction_residual_scale_get;
*swig_residual_scale_set = *Math::LOESS::_swigc::prediction_residual_scale_set;
*swig_df_get = *Math::LOESS::_swigc::prediction_df_get;
*swig_df_set = *Math::LOESS::_swigc::prediction_df_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_prediction(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_prediction($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::anova_struct ##############

package Math::LOESS::_swig::anova_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_dfn_get = *Math::LOESS::_swigc::anova_struct_dfn_get;
*swig_dfn_set = *Math::LOESS::_swigc::anova_struct_dfn_set;
*swig_dfd_get = *Math::LOESS::_swigc::anova_struct_dfd_get;
*swig_dfd_set = *Math::LOESS::_swigc::anova_struct_dfd_set;
*swig_F_value_get = *Math::LOESS::_swigc::anova_struct_F_value_get;
*swig_F_value_set = *Math::LOESS::_swigc::anova_struct_F_value_set;
*swig_Pr_F_get = *Math::LOESS::_swigc::anova_struct_Pr_F_get;
*swig_Pr_F_set = *Math::LOESS::_swigc::anova_struct_Pr_F_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_anova_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_anova_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::LOESS::_swig::confidence_intervals ##############

package Math::LOESS::_swig::confidence_intervals;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::LOESS::_swig );
%OWNER = ();
%ITERATORS = ();
*swig_fit_get = *Math::LOESS::_swigc::confidence_intervals_fit_get;
*swig_fit_set = *Math::LOESS::_swigc::confidence_intervals_fit_set;
*swig_upper_get = *Math::LOESS::_swigc::confidence_intervals_upper_get;
*swig_upper_set = *Math::LOESS::_swigc::confidence_intervals_upper_set;
*swig_lower_get = *Math::LOESS::_swigc::confidence_intervals_lower_get;
*swig_lower_set = *Math::LOESS::_swigc::confidence_intervals_lower_set;
sub new {
    my $pkg = shift;
    my $self = Math::LOESS::_swigc::new_confidence_intervals(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::LOESS::_swigc::delete_confidence_intervals($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::LOESS::_swig;

*TRUE = *Math::LOESS::_swigc::TRUE;
*FALSE = *Math::LOESS::_swigc::FALSE;


package Math::LOESS::_swig;

use strict;

use PDL::Core qw(pdl);

sub darray_to_pdl {
    my ($a, $n) = @_;

    my @array = map { doubleArray_getitem($a, $_); } (0 .. $n - 1); 
    return pdl(\@array);
}

sub pdl_to_darray {
    my ($p) = @_;

    my $n = $p->dim(0);
    my @array = $p->list;
    my $a = new_doubleArray($n);
    for my $i (0 .. $n - 1) {
        doubleArray_setitem($a, $i, $array[$i]);
    }
    return $a;
}

1;
